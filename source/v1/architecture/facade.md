---
title: 服务门面
---

# 服务门面

门面模式(Facade)又称外观模式，用于为子系统中的一组接口提供一个一致的界面。

门面模式定义了一个高层接口，这个接口使得子系统更加容易使用：引入门面角色之后，用户只需要直接与门面角色交互，用户与子系统之间的复杂关系由门面角色来实现，从而降低了系统的耦合度。

## 实现门面

您只需要继承自`CatLib.Facade`即可实现门面,一般情况框架的门面都是放在`CatLib.Facades`命名空间下的。

```csharp
namespace CatLib.Facades
{
    public class FileSystem : Facade<IFileSystem>
    {
    }
}
```

## 使用门面

使用门面是非常简单的，您只需要访问门面下的`Instance`即可访问对应实现。

```csharp
using CatLib.Facades;

FileSystem.Instance.HelloWorld(); // 输出: hello world
```

> 通过代码生成技术，可以将门面调用简化到`FileSystem.HelloWorld()`

## 门面的工作原理

门面是一个为容器中对象，提供访问方式的类。该机制原理由`CatLib.Facade`类实现。

门面类只需要提供服务的接口类型。Facade底层会通过这个服务接口来向容器请求服务的实现，并且将其缓存，以达到和源生代码一致的性能。

> 服务实现发生变更时，门面会自动更新服务实现。

## 合理使用门面

门面有诸多优点，其提供了简单、易记的语法，让我们无需记住长长的类名即可使用服务提供的功能特性。

但是，使用门面也有需要注意的地方，一个最主要的危险就是类范围蠕变。由于门面如此好用并且不需要注入，在单个类中使用过多门面，会让类很容易变得越来越大。使用依赖注入则会让此类问题缓解，因为一个巨大的构造函数会让我们很容易判断出类在变大。因此，使用门面的时候要尤其注意类的大小，以便控制其有限职责。

## 门面与静态函数

门面为服务容器中的绑定类提供了一个`静态`接口。 

CatLib 的门面作为服务容器中底层类的`静态代理`，相比于传统静态方法，在维护时能够提供更加易于测试、灵活、及简明优雅。